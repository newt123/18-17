.TH JAMFILE 5 "30 August 1993"
.de BB
.RS
.PP
.ft CW
.na
.nf
..
.de BE
.RE
.ft R
.fi
.ad
..
.de XB
Example:
.BB
..
.de XE
.BE
..
.SH NAME
\fBJamfile\fR \- per-directory \fBJam\fR(1) instructions
.SH DESCRIPTION
.PP
\fBJamfile\fR is the file that tells the build tool \fBJam\fR what to
do in the current directory.  This man page gives examples for a
\fBJamfile\fR.
.PP
The rules used here are defined by \fBJambase\fR(5), the \fBJam\fR
boilerplate.  \fBJambase\fR contains a set of \fBJam\fR rule
definitions that provide the roughly \fBmake\fR(1)-like functionality
shown here.
.SH EXECUTABLES AND LIBRARIES
.SS Main Rule
.PP
The \fIMain\fR rule handles the compiling of one or more files and linking
the resulting objects into an executable.
.XB
Main myprog : main.c util.c ;
.XE
.PP
This compiles main.c and util.c and links main.o and util.o into myprog.
.SS Library Rule
.PP
The \fILibrary\fR rule handles the compiling of one or more sources,
archiving the resulting objects, and then deleting the objects.
.XB
Library libstring.a : strcmp.c strcpy.c strlen.c ;
Library libtree.a : treemake.c treetrav.c ;
.XE
.SS LinkLibraries Rule
.PP
To link executables against libraries that are built, indicate this
with the \fILinkLibraries\fR rule.
.XB
Main myprog : main.c util.c ;
LinkLibraries myprog : libstring.a libtree.a ;

Library libstring.a : strcmp.c strcpy.c strlen.c ;
Library libtree.a : treemake.c treetrav.c ;
.XE
.PP
The ordering of the lines above is not critical.
.SS Variables
.PP
The following variables control the linking of executables and the
archiving of libraries.
.BB
AR              archive command (ar ru)
EXEMODE         permission set on executable after linking (711)
LINK            linker command (cc)
LINKFLAGS       linker flags ()
LINKLIBS        additional libraries that aren't dependents ()
RANLIB          name of ranlib program, if any (ranlib)
.BE
.PP
The difference between and the arguments to \fILinkLibraries\fR
and the value of $(LINKLIBS) is that the former are expected to be
real, buildable libraries, while the latter are just handed without
inspection to the $(LINK) command.  The ordering on the $(LINK)
command line is first \fILinkLibraries\fR, then $(LINKLIBS).
.XB
Main xprog : xprog.c ;
LinkLibraries xprog : libxutil.a ;
LINKFLAGS on xprog = -Bstatic ;
LINKLIBS on xprog = -lXext -lX11 ;

Library libxutil.a : xtop.c xbottom.c xutil.c ;
.XE
.SH COMPILING
.SS Objects Rule
.PP
Compiling occurs normally as a byproduct of \fIMain\fR or \fILibrary\fR
calling the \fIObjects\fR rule on the source files.  \fIObjects\fR can be
called directly.
.XB
Objects a.c b.c c.c ;
.XE
.PP
This compiles a.c into a.o, b.c into b.o, etc.
.SS Object Rule
.PP
\fIObjects\fR gets its work done by calling the \fIObject\fR rule on
each of the source files, assuming that the object name itself will be
the source file name, with the suffix replaced appropriately.  To compile
a single source file directly, use the \fIObject\fR rule.
.XB
Object foo.o : foo.c ;
.XE
.PP
The \fIObject\fR rule doesn't require that the object name bear any
relationship to the source.  It is thus possible to compile the same
file into different objects.
.XB
Object a.o : foo.c ;
Object b.o : foo.c ;
Object c.o : foo.c ;
.XE
.PP
This compiles foo.c (three times) into a.o, b.o, and c.o.  Later examples
show how this is useful.
.PP
The \fIObject\fR rule looks at the suffix of the source file and calls
the appropriate rules to do the actual compiling.  This invariably
involves a call to the \fICc\fR to turn the .c into a .o, but may also
require a call to other rules to turn the source file into a .c. 
Thus the \fIObject\fR rule is responsible for the generation of an
object file from any type of source.
.XB
Object grammar.o : grammar.y ;
Object scanner.o : scanner.l ;
Object fastf.o : fastf.f ;
Object util.o : util.c ;
.XE
.PP
In addition to calling the compiling rule, \fIObject\fR sets up a bunch
of variables specific to the source and target files.  These are discussed
below.
.SS Cc, Yacc, Lex, etc. Rules
.PP
The \fIObject\fR calls compiling rules specific to the suffix of the
source file.  Because the extra work done by the \fIObject\fR rule, it
is not always useful to call the compiling rules directly.  But the
adventurous user might attempt it.  
.XB
Yacc grammar.c : grammar.y ;
Lex scan.c : scan.l ;
Cc prog.o : prog.c ;
.XE
.PP
These examples individually run \fByacc\fR(1), \fBlex\fR(1), and the
C compiler on their sources.
.SS UserObject Rule
Any files with suffixes not understood by the \fIObject\fR rule are
passed to the \fIUserObject\fR rule.  The default definition of
\fIUserObject\fR simply emits a warning that the suffix is not understood.
This rule definition is intended to be replaced with a one that
recognises the suffix.  
.XB
rule UserObject
{
    switch $(>)
    {
    case *.s    : As $(<) : $(>) ;
    case *      : ECHO "unknown suffix on" $(>) ;
    }
}

rule As
{
    DEPENDS $(<) : $(>) ;
}

actions As
{
    as -o $(<) $(>)
}

Library libsys.a : alloca.s memcpy.s ;
.XE
.PP
It should be mentioned that this example is contrived, in that the
\fB.s\fR suffix is already handled by \fIObject\fR.
.SS Variables
.PP
The following variables control the compiling of source files.
.BB
CC              The C Compiler (cc)
CCFLAGS         C compiler flags()
HDRS            non-standard header directories ()
LEX             The Lex program (lex)
OPTIM           optimization flag, if desired (-O)
STDHDRS         standard header directories (/usr/include)
YACC            The Yacc program (yacc -d)
.BE
.PP
$(CC), $(CCFLAGS), $(OPTIM), and $(HDRS) all affect the compiling of
C files.  $(CCFLAGS) and $(OPTIM) are split so that the optimization of
a file can be altered easily without affecting other flags.
.PP
$(HDRS) lists the directories to search for header files, and it is
used in two ways: first, it is passed to the C compiler (with the 
flag \fB-I\fR prepended); second, it is used by \fIHdrRule\fR
to locate the header files whose names were found when scanning source
files.  $(STDHDRS) lists the header directories that the C compiler
knows about:  it is not passed to the C compiler, but is used by
\fIHdrRule\fR.
.PP
Note that these flags, if set as target-specific variables, must be
set on the target - the object file - not the source file.
.XB
Library libximage.a : xtiff.c xjpeg.c xgif.c ;

HDRS on xjpeg.o = /usr/local/src/jpeg ;
CCFLAGS on xtiff.o = -DHAVE_TIFF ;
.XE
.SS ObjectCcFlags, ObjectHdrs Rules
.PP
$(CCFLAGS) and $(HDRS) can be manipulated directly, but there are two
rules that allow these variables to be set by referring to the original
source file name, rather than to the derived object file name.
\fIObjectCcFlags\fR adds object-specific flags to the $(CCFLAGS) variable,
and \fIObjectHdrs\fR add object-specific directories to the $(HDRS)
variable.
.XB
Main xviewer : viewer.c ;
ObjectCcFlags viewer.c : -DXVERSION ;
ObjectHdrs viewer.c : /usr/include/X11 ;
.XE
.PP
Actually, the file suffix (\fB.c\fR in this case) is ignored: the
rules know to refer to the object.
.SH HEADER FILE PROCESSING
.PP
One of the functions of the \fIObject\fR rule is to scan source files
for (C style) header file inclusions.  To do so, it sets the
Jam-special variables $(HDRSCAN) and $(HDRRULE) (specifically for the
source file).  The presence of these variables triggers a special
mechanism in \fBJam\fR for scanning a file for header file inclusions
and invoking a rule with the results of the scan.  The $(HDRSCAN)
variable is set to an \fBegrep\fR(1) pattern that matches "#include"
statements in C source files, and the $(HDRRULE) variable is set to the
name of the rule that gets invoked as such:
.BB
$(HDRRULE) source-file : included-files ;
.BE
.PP
This rule is supposed to set up the dependencies between the source
file and the included files.  The \fIObject\fR rule uses
\fIHdrRule\fR to do the job.  \fIHdrRule\fR itself expects another
variable, $(HDRSEARCH), to be set to the list of directories where the
included files can be found.  \fIObject\fR does this as well, setting
$(HDRSEARCH) to $(HDRS) and $(STDHDRS).
.PP
The header file scanning occurs during the "file binding" phase of
\fBJam\fR, which means that the target-specific variables (for the
source file) are in effect.  To accomodate nested includes, one of the
\fIHdrRule\fR's jobs is to pass the values of $(HDRRULE), $(HDRSCAN),
and $(HDRSEARCH) onto the included files, so that they will be scanned
as well.
.SS HdrRule Rule
.PP
\fIHdrRule\fR can be invoked directly, but it is most usable as the
boilerplate in a user-defined $(HDRRULE).
.XB
Main mkhdr : mkhdr.c ;
Main ugly : ugly.c ;

HDRRULE on ugly.c = BuiltHeaders ;

rule BuiltHeaders
{
        DEPENDS $(>) : mkhdr ;
        HdrRule $(<) : $(>) ;
}
.XE
.PP
This example just says that the files included by "ugly.c" are generated
by the program "mkhdr", which can be built from "mkhdr.c".  By calling
\fIHdrRule\fR at the end of \fIBuiltHeaders\fR, all the gadgetry of 
\fIHdrRule\fR doesn't need to be duplicated.
.SS Variables
.PP
The complete list of variables used by the \fIHdrRule\fR coterie are:
.BB
HDRRULE         scan rule, when set activates scanning (HdrRule)
HDRSCAN         scan pattern ($(HDRPATTERN))
HDRSEARCH       search list for HdrRule ($(HDRS) $(STDHDRS))
HDRS            non-standard directories for headers ()
STDHDRS         standard directories for headers (/usr/include)
HDRPATTERN      scan pattern for $(HDRSCAN) (ugly egrep expression)
.BE
.SH COPYING FILES
.SS File Rule
The \fIFile\fR rule copies one file to another.
The target name needn't bear any relationship to the source name.
.XB
File $(DESTDIR)/foo : bar ;
.XE
.SS Buld Rule
The \fIBulk\fR rule is a shorthand for many invocations of the \fIFile\fR
rule when all files are going to the same directory.
.XB
Bulk /usr/local/lib/grob : grobvals.txt grobvars.txt ;
.XE
.SS Shell Rule
The \fIShell\fR rule is like the \fIFile\fR rule, except that it makes
sure the first line of the target is "#!/bin/sh" and sets the permission
to make the file executable.
.XB
Shell /usr/local/bin/add : add.sh ;
.XE
.SS Variables
The following variables are used when copying files:
.BB
FILEMODE        permissions for target file (644)
SHELLHEADER     first line of shell scripts (#!/bin/sh)
SHELLMODE       permissions for shell scripts (755)
.BE
.PP
These can be set target-specific.
.XB
Shell /usr/local/bin/add : add.awk ;
SHELLHEADER on /usr/local/bin/add = "#!/bin/awk -f" ;
.XE
.SH INSTALLING FILES
.SS InstallBin Rule
.PP
\fIInstallBin\fR calls \fBinstall\fR(1) to install executables in 
the target directory.  $(BINDIR) is set to /usr/local/bin for convenience.
.XB
Main add : add.c ;
Main sub : sub.c ;
InstallBin $(BINDIR) : add sub ;
.XE
.SS InstallLib Rule
\fIInstallLib\fR calls \fBinstall\fR(1) to install files in the target
directory.  $(LIBDIR) is set to /usr/local/lib for convenience.
.XB
InstallLib $(LIBDIR) : bighelp.txt ;
.XE
.SS InstallMan Rule
.PP
\fIInstallMan\fR calls \fBinstall\fR(1) to install manual pages in 
the appropriate subdirectories of the target directory.  $(MANDIR)
is set to /usr/local/man for convenience.
.XB
InstallMan /usr/local/man : add.1 sub.1 bigfile.8 ;
.XE
.SS InstallShell Rule
.PP
\fIInstallShell\fR calls \fBinstall\fR(1) to install shell scripts in 
the target directory.
.XB
Shell bugs : bugs.sh ;
InstallShell /usr/local/bin : bugs ;
.XE
.PP
The difference between \fIShell\fR and \fIInstallShell\fR is not much: they
both copy the source to the target.  The former also makes
sure the script begins with the magic string (#!/bin/sh); the latter uses
\fIinstall\fR(1) for the copy.
.SS Variables
.PP
The following variables control the installation rules:
.BB
BINDIR          InstallBin directory (/usr/local/bin)
LIBDIR          InstallLib directory (/usr/local/lib)
MANDIR          InstallMan directory (/usr/local/man)
INSTALL		The install program; uses cp if not set (install)
FILEMODE        generic permissions for InstallLib, InstallMan (644)
EXEMODE         generic permissions for InstallBin (711)
SHELLMODE       generic permissions for InstallShell (755)
.BE
.PP
These variable must be set (globally) before calling the install rules
for them to take effect.
.SH HANDLING DIRECTORY TREES
.PP
\fBJambase\fR includes a few rules for building whole directory trees.
If these rules do not accomodate a particular project, they can be
wrapped with custom extentions or simply replaced.
.PP
The handling of a directory tree requires the user to set an
environment variable pointing to the base of the tree.  The variable's
name is left up to the user, but in this example we use $(TOP).
.SH SubInclude Rule
.PP
The SubInclude rule sources the \fIJamfile\fR from the named subdirectory.
It takes as its first argument the name of the environment variable that
points to the root of the directory tree, and as subsequent arguments the
directory names leading from the root to the \fIJamfile\fR to be included.
Note that the name of the subdirectory is given as individual elements:
the SubInclude rule does not use system-specific file name syntax.
.PP
The recommended practice is only to include one level of subdirectories
at a time, and let the \fBJamfile\fR in each subdirectory include its
subdirectories.
.XB
# Top level Jamfile for mondo project.  
# 
# $(TOP) points to root of mondo tree (set in environment).

SubInclude TOP src ;	
SubInclude TOP man ;
SubInclude TOP misc ;
.XE
.SS SubDir Rule
.PP
In the \fBJamfile\fR of a directory that has contents other than just
more subdirectories, the \fBSubDir\fR rule announces the name of the
directory, in the same format as the \fBSubInclude\fR rule.  While the
directory for \fBSubDir\fR could be inferred from the \fRSubInclude\fR,
restating it in each file makes it possible to invoke \fBJam\fR in a
subdirectory without having to start at the root.  The \fBSubDir\fR
rule should be invoked before any other rule.
.XB
# Mondo Man page directory.

SubDir TOP man ;

InstallMan /usr/local/man : mondo.1 mondofile.5 mondod.8 ;
.XE
.PP
If a subdirectory has both subdirectories of its own and files that
need building, the \fBSubIncludes\fR should go at the end of the \fBJamfile\fR,
after the effects of the \fBSubDir\fR rule are needed.
.XB
# Mondo src code.

SubDir TOP src ;

Main mondo : mondo.c ;
LinkLibraries mondo : $(TOP)/lib/libmisc.a $(TOP)/lib/libutil.a ;

SubInclude TOP src misc ;
SubInclude TOP src util ;
.XE
.SS SubDirCcFlags, SubDirHdrs Rules
.PP
These two rules set the values of $(SUBDIRCCFLAGS) and $(SUBDIRHDRS),
which are used by the \fBObject\fR rule when setting the target-specific
values for $(CCFLAGS) and $(HDRS).  The \fBSubDir\fR rule clears these
variables out, and thus they provide directory-specific values of $(CCFLAGS)
and $(HDRS).
.XB
SubDir TOP src util ;

SubDirHdrs $(TOP)/src/hdr ;
SubDirCcFlags -DUSE_FAST_CODE ;
.SS Variables
The following variables are used when \fBJam\fR spans multiple directories:
.BB
LOCATE_TARGET	Directory to put targets.
SEARCH_SOURCE	Directory to find sources.
SOURCE_GRIST	Something to perturb source file names.
SUBDIRCCFLAGS	Per-directory CCFLAGS.
SUBDIRHDRS	Per-directory HDRS.
.BE
.PP
\fBSubDir\fR sets $(LOCATE_TARGET) and $(SEARCH_SOURCE) to be the
directory given to \fBSubDir\fR.  These variables are used extensively
by rules in \fBJambase\fR: most rules that generate targets (like
\fBMain\fR, \fBObject\fR, etc.) set $(LOCATE) to be $(LOCATE_TARGET)
for the targets they generate, and rules that use sources (most all of
them) set $(SEARCH) to be $(SEARCH_SOURCE) for the sources they use.
.PP
$(LOCATE) and $(SEARCH) are better explained in \fBJam\fR(1), but in 
brief they tell \fBJam\fR where to create new targets and find existing
ones, respectively.
.PP
\fBSubDir\fR sets $(SOURCE_GRIST) to be a value derived from the
directory name.  $(SOURCE_GRIST) is used by the rules that take
source files to perturb file names in different directories that
would otherwise be the same.
.PP
$(SUBDIRCCFLAGS) and $(SUBDIRHDRS) are cleared by \fBSubDir\fR,
set by \fBSubDirCcFlags\fR and \fBSubDirHdrs\fR, and then used
by \fBObject\fR when setting the target-specific values for $(CCFLAGS)
and $(HDRS).  They could also be set directly.
.PP
It should be noted that the user can set these variables independently
of \fBSubDir\fR, or after it.  The most profitable example is setting
$(LOCATE_TARGET) to be a directory outside the source tree: in this
case, \fBJam\fR can build without touching the source tree.
.SH MISCELLANEOUS
.SS Clean Rule
.PP
In addition to their other duties, all rules listed above arrange for
any generated target to be a dependency of the fake target "clean".
The actions defined for "clean" are to remove all dependent targets
(thus a "jam clean" removes all generated files).  To arrange this, all
rules call the \fIClean\fR rule.  If a user-provided rule creates
targets, these targets can be included in the cleanup as well:
.XB
rule MakeHeader
{
        # Generated header depends on mkhdr

        DEPENDS $(<) : mkhdr ;

        # Make sure 'jam clean' gets these generated headers

        Clean clean : $(<) ;
}

actions MakeHeader
{
        mkhdr $(<) 
}
.XE
.PP
The target "clean" is the standard one for cleaning all files, but
other targets for \fIClean\fR can be invented.  If a rule produces a
type of intermediate files, a different \fIClean\fR target can be used
to rid them.
.XB
rule M4 {
	# File depends on it's m4 source

        DEPENDS $(<) : $(>) ;

        # Rid generated m4 files with 'jam m4clean'

        Clean m4clean : $(<) ;
}

actions M4
{
        m4 < $(>) > $(<)
}
.XE
.SS LibraryFromObjects Rule
.PP
Sometimes the \fILibrary\fR rule's straightforward compiling of source
into object modules to be archived isn't flexible enough.  The 
\fILibraryFromObjects\fR rule does the archiving (and deleting) job
of the \fILibrary\fR rule, but not the compiling.  The user can make
use of the \fIObjects\fR or \fIObject\fR rule for that.
.XB
LibraryFromObjects max.o min.o ;
Object max.o : maxmin.c ;
Object min.o : maxmin.c ;
ObjectCcFlags max.c : -DUSEMAX ;
ObjectCcFlags min.c : -DUSEMIN ;
.XE
.PP
This compiles the same source file into two different objects, with different
compile flags, and archives them.  Note that \fIObjectCcFlags\fR refered to the
(nonexistent) source file names for the objects.
.SS MainFromObjects Rule
.PP
Similar to \fILibraryFromObjects\fR, \fIMainFromObjects\fR does the linking
part of the \fIMain\fR rule, but not the compiling.
.XB
MainFromObjects w : w.o ;
MainFromObjects uptime : uptime.o ;
Object w.o : uptime.c ;
Object uptime.o : uptime.c ;
ObjectCcFlags w.c : -DW_CODE ;
.XE
.SS RmTemps Rule
.PP
Some intermediate files are meant to be temporary.  The \fIRmTemps\fR
rule makes such files with the TEMPORARY attribute, and then deletes
them after they are used.  To delete them only when they are finished
being used, \fIRmTemps\fR must be the rule (with actions) invoked on
the target that uses the temporary files, and the sources to
\fIRmTempts\fR must be the temporary files themselves.
.XE
SpecialUserRuleA foo : bar ;
SpecialUserRuleB ola : foo ;
RmTemps ola : foo ;
.XE
This says: build \fIfoo\fR using \fISpecialUserRuleA\fR and \fIola\fR
using \fISpecialUserRuleB\fR.  Once that is done, remove \fIfoo\fR.
.SH USER-PROVIDED JAM RULES
.PP
It is possible to put user-provided rules and constructs directly into
the \fBJamfile\fR, but to share them they should be placed in their own
rule file.  If the variable $(JAMUSER) is set to the name of this file,
\fBJambase\fR includes it just before reading the \fBJamfile\fR.
